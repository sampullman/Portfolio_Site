
function CollisionSystem() {
    this.components = [];
    this.v1 = new Vec2();
    this.update = function(timeDelta, parent) {
        var c1, c2;
        for(var i=0;i<this.components.length;i+=1) {
            for(var j=i+1;j<this.components.length;j+=1) {
                c1 = this.components[i];
                c2 = this.components[j];
                if(c1.testCollision(c2, this.v1)) {
                    var point = new Vec2(this.v1.x, this.v1.y);
                    c1.collide(c2, point);
                    c2.collide(c1, point);
                }
            }
        }
        this.components.length = 0;
    };
    this.register = function(component) {
        this.components.push(component);
    };
}

var Collision = {
    CollisionResponse: function() {
        this.v1 = new Vec2();
        this.v2 = new Vec2();
        this.update = function(timeDelta, parent) {
            if(parent.collider) {
                //error = parent.collisionSegment.nor;
                //this.v1.set(parent.colliderSegment).sub(parent.collisionSegment);
                //this.v1.mul(parent.colliderSegment.nor);
                //parent.move(this.v1.set(parent.vel).scale(-1));
                /* Hack to work with axis aligned boxes */
                var mySeg = parent.collisionSegment;
                var p = parent.collisionPoint;
                var colNor = parent.colliderSegment.nor;
                this.v1.set(colNor).mul(mySeg.nor);
                mySeg.dst(p, colNor, this.v1);
                parent.move(this.v1.scale(1.01));
                this.v2.set(colNor).scale(-2 * parent.vel.dot(colNor)).add(parent.vel)
                    .mul(parent.bounce);
                error = this.v2.y;
                if(this.v2.y < 0 && this.v2.y > -60) this.v2.y *= 0.7;
                //if(this.v2.len2() < 5000) this.v2.scale(0.5);
                parent.acc.y = -1000;
                parent.vel.set(this.v2);
                parent.collider = null;
            }
        }
    },
    getIntersection: function(seg1, seg2, result) {
        var p1=seg1.p1, p2=seg1.p2, q1=seg2.p1, q2=seg2.p2;
        var rx=p2.x - p1.x, ry=p2.y-p1.y;
        var sx=q2.x - q1.x, sy=q2.y-q1.y;
        var rcs = rx*sy - ry*sx;
        var qmpX=q1.x - p1.x, qmpY=q1.y - p1.y;
        var qmpcr = (qmpX*ry - qmpY*rx);
        if(rcs == 0) {
            if(qmpcr == 0) {
                result.set(p1.x + 0.5*rx, p1.y + 0.5*ry);
            } else {
                result.set(0, 0);
                return false;
            }
        } else {
            var t = (qmpX*sy - qmpY*sx) / rcs;
            var u = qmpcr / rcs;
            if(t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                result.setXY(q1.x + u*sx, q1.y + u*sy);
            } else {
                result.set(0, 0);
                return false;
            }
        }
        return true;
    },
    Poly: function(system, parent, segments) {
        this.system = system;
        this.segments = segments;
        this.vel;
        this.parent = parent;
        this.ColliderSegment = null;
        this.collisionSegment = null;
        this.testCollision = function(other, result) {
            for(var i=0;i<this.segments.length;i+=1) {
                for(var j=0;j<other.segments.length;j+=1) {
                    var mySeg=this.segments[i], otherSeg=other.segments[j];
                    if(Collision.getIntersection(mySeg, otherSeg, result)) {
                        this.collisionSegment = mySeg;
                        this.colliderSegment = otherSeg
                        other.collisionSegment = otherSeg;
                        other.colliderSegment = mySeg;
                        return true;
                    }
                }
            }
            return false;
        };
        this.update = function(timeDelta, parent) {
            this.vel = parent.vel;
            this.system.register(this);
        };
        this.collide = function(other, point) {
            //error = point;
            parent.collider = other.parent;
            other.parent.collider = this.parent;
            this.parent.collisionPoint = point;
            this.parent.collisionSegment = this.collisionSegment;
            this.parent.colliderSegment = this.colliderSegment;
        };
    },
    // A line segment 
    Segment: function(p1, p2, nor) {
        this.v1 = new Vec2();
        this.p1 = p1; this.p2 = p2;
        this.nor = nor;
        this.update = function(timeDelta, parent) {
            var minX = parent.getXMinOffset();
            var maxX = parent.getXMaxOffset();
            var minY = parent.getYMinOffset();
            var maxY = parent.getYMaxOffset();
            if(parent.pos.x + minX < this.xMin) {
                parent.pos.x = this.xMin - minX;
            } else if(parent.pos.x + maxX > this.xMax) {
                parent.pos.x = this.xMax - maxX;
            }
            if(parent.pos.y + minY < this.yMax) {
                parent.pos.y = this.yMax - minY;
            } else if(parent.pos.y + maxY > this.yMin) {
                parent.pos.y = this.yMin - maxY;
                parent.acc.addXY(0, -1*physics.gravity.y);
                parent.vel.y = 0;
            }
        };
        this.dst = function(p, dir, res) {
            var dx1 = (this.p1.x - p.x) * dir.x;
            if(dx1 < 0) {
                res.x = -dx1;
            } else {
                var dx2 = (this.p2.x - p.x) * dir.x;
                if(dx2 < 0) {
                    res.x = dx2
                }
            }
            var dy1 = (this.p1.y - p.y) * dir.y;
            if(dy1 < 0) {
                res.y = -dy1;
            } else {
                var dy2 = (p.y - this.p2.y) * dir.y;
                if(dy2 > 0) {
                    res.y = -dy2;
                } else {
                    
                }
            }
        };
    }
}